# Export a project to make it usable for other projects.
#
#   ryppl_export(
#     [TARGETS [targets...] ]
#     [DEPENDS [packages...] ]
#     [RECOMMENDS [packages...] ]
#     [INCLUDE_DIRECTORIES [dirs...] ]
#     [DEFINITIONS [compile_flags...] ]
#     [CODE [lines...] ]
#     [VERSION version]
#     )
#
# ryppl_export writes targets declared in the current listfile and
# their usage requirements into a <packagename>Config.cmake file that
# can be found and used by CMake's find_package().  It also calls
# install() to generate installation instructions for dev, bin, and
# dbg packages, and registers the exported package in the CMake
# package registry.
#
# TARGETS names the CMake targets that are part of the package being
# exported.
#
# DEPENDS names any additional packages needed by any project using
# the one being exported.  For example, if library A can't be used
# without library B, library A would declare B in its DEPENDS argument
#
# INCLUDE_DIRECTORIES supplies a list of arguments that will be passed
# to CMake's include_directories() immediately, *and* in the generated
# <packagename>Config.cmake file.  Pass the names of directories that
# users of the exported package will need in their #include paths.
#
# DEFINITIONS supplies compilation flags required by users of the
# exported package.
#
# CODE strings are appended as raw CMake code to the
# <packagename>Config.cmake file, one per line.
#
# If VERSION is given, a basic <package>ConfigVersion.cmake file is
# created. This file is placed both in the build directory and in the
# install directory.

#=============================================================================
# Copyright (C) 2011-2012 Daniel Pfeifer <daniel@pfeifer-mail.de>
#
# Distributed under the Boost Software License, Version 1.0.
# See accompanying file LICENSE_1_0.txt or copy at
# http://www.boost.org/LICENSE_1_0.txt
#=============================================================================

include(CMakeParseArguments)
include(CMakePackageConfigHelpers)

# Export of projects
function(ryppl_export)

  cmake_policy(SET CMP0019 NEW)

  set(parameters
    CODE
    DEFINITIONS
    DEPENDS
    RECOMMENDS
    INCLUDE_DIRECTORIES
    TARGETS
    )
  cmake_parse_arguments(EXPORT "" "VERSION" "${parameters}" ${ARGN})

  if(EXPORT_VERSION)
    set(_config_version_file
      "${CMAKE_BINARY_DIR}/${PROJECT_NAME}/${PROJECT_NAME}ConfigVersion.cmake"
      )
    write_basic_package_version_file("${_config_version_file}"
      VERSION ${EXPORT_VERSION}
      COMPATIBILITY SameMajorVersion
      )
    install(FILES "${_config_version_file}"
      DESTINATION lib/${PROJECT_NAME}
      COMPONENT   dev
      )
  endif()

  # Set up variables to hold fragments of the
  # <packagename>Config.cmake file we're generating
  set(_find_package )

  # Each dependency contributes its own dependencies, include directories, etc.
  foreach(depends ${EXPORT_DEPENDS})
    string(FIND ${depends} " " index)
    string(SUBSTRING ${depends} 0 ${index} name)
    set(_find_package "${_find_package}find_package(${depends} \${${PROJECT_NAME}_FIND_DEPENDENCY_REQUIRED})\n")

    if (${depends} MATCHES "^Boost")
      string(REGEX REPLACE "^Boost" "" _libname ${depends})
      string(TOLOWER ${_libname} libname)
      list(APPEND iface_deps boost::${libname}::iface)
    endif()
  endforeach()
  if (iface_deps)
    list(REMOVE_DUPLICATES iface_deps)
  endif()

  set(_config_file    "${CMAKE_BINARY_DIR}/${PROJECT_NAME}/${PROJECT_NAME}Config.cmake")

  set(_include_guard "__${PROJECT_NAME}Config_included")

  if (NOT (${PROJECT_NAME} MATCHES "^Boost"))
    # Hack for Quickbook
    return()
  endif()

  string(REGEX REPLACE "^Boost" "" _libname ${PROJECT_NAME})
  string(TOLOWER ${_libname} libname)

  add_library(boost::${libname}::iface INTERFACE)
  set_property(TARGET boost::${libname}::iface PROPERTY INTERFACE_INCLUDE_DIRECTORIES
    "$<BUILD_INTERFACE:${CMAKE_CURRENT_BINARY_DIR};${CMAKE_CURRENT_SOURCE_DIR}/include>"
    "$<INSTALL_INTERFACE:${CMAKE_INSTALL_PREFIX}/include>"
  )

  add_library(boost::${libname} INTERFACE)

  target_link_libraries(boost::${libname}
    LINK_INTERFACE_LIBRARIES
      boost::${libname}::iface
      ${iface_deps}
      ${EXPORT_TARGETS}
  )

  install(TARGETS ${EXPORT_TARGETS} EXPORT ${PROJECT_NAME}Targets
    RUNTIME DESTINATION bin
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
  )
  install(TARGETS boost::${libname} boost::${libname}::iface EXPORT ${PROJECT_NAME}Targets)

  #
  # Write the file
  #
  file(WRITE "${_config_file}"
    "# Generated by Boost.CMake\n\n"
    "if(${_include_guard})\n"
    "  return()\n"
    "endif()\n"
    "set(${_include_guard} TRUE)\n"
    "if (${PROJECT_NAME}_FIND_REQUIRED)\n"
    "  set(${PROJECT_NAME}_FIND_DEPENDENCY_REQUIRED REQUIRED)\n"
    "endif()\n"
    )

  if(_find_package)
    file(APPEND "${_config_file}"
      "${_find_package}\n"
      )
  endif()

  foreach(code ${EXPORT_CODE})
    file(APPEND "${_config_file}" "${code}")
  endforeach()

  set(targetsfile ${PROJECT_NAME}Targets.cmake)
  install(EXPORT ${PROJECT_NAME}Targets FILE ${targetsfile} DESTINATION lib/${PROJECT_NAME})
  file(APPEND "${_config_file}" "include(\${CMAKE_CURRENT_LIST_DIR}/${targetsfile})")

  export(TARGETS boost::${libname} boost::${libname}::iface FILE ${CMAKE_BINARY_DIR}/${PROJECT_NAME}/${targetsfile})

  install(FILES    "${_config_file}"
    DESTINATION    "lib/${PROJECT_NAME}"
    COMPONENT      "dev"
  )

  if (EXISTS include/boost) # Hack for auto_index
    install(DIRECTORY
      include/boost
      DESTINATION include
    )
  endif()

  # TODO: [NAMELINK_ONLY|NAMELINK_SKIP]
  install(TARGETS ${libraries} ${executables}
    ARCHIVE
      DESTINATION lib
      COMPONENT   dev
      CONFIGURATIONS "Release"
    LIBRARY
      DESTINATION lib
      COMPONENT   bin
      CONFIGURATIONS "Release"
    RUNTIME
      DESTINATION bin
      COMPONENT   bin
      CONFIGURATIONS "Release"
    )
  install(TARGETS ${libraries}
    ARCHIVE
      DESTINATION lib
      COMPONENT   dbg
      CONFIGURATIONS "Debug"
    LIBRARY
      DESTINATION lib
      COMPONENT   dbg
      CONFIGURATIONS "Debug"
    RUNTIME
      DESTINATION bin
      COMPONENT   dbg
      CONFIGURATIONS "Debug"
    )

#   export(PACKAGE ${PROJECT_NAME})

  if(RYPPL_PROJECT_DUMP_DIRECTORY)
    set(xml "<?xml version='1.0' ?>\n<cmake-project>\n")
    ryppl_xml_append_text(xml "  " name "${PROJECT_NAME}")
    get_filename_component(realpath . REALPATH)
    ryppl_xml_append_text(xml "  " source-directory "${realpath}")
    get_property(find_package_args GLOBAL PROPERTY ${PROJECT_NAME}_FIND_PACKAGE_ARGS)
    foreach(find_package ${find_package_args})
      ryppl_xml_append_list(xml "  " find-package arg "${find_package}")
    endforeach()
    ryppl_xml_append_list(xml "  " depends dependency ${EXPORT_DEPENDS})
    ryppl_xml_append_list(xml "  " include-directories directory ${EXPORT_INCLUDE_DIRECTORIES})
    ryppl_xml_append_list(xml "  " libraries library ${libraries})
    ryppl_xml_append_list(xml "  " executables executable ${executables})
    set(xml "${xml}</cmake-project>\n")
    file(WRITE "${RYPPL_PROJECT_DUMP_DIRECTORY}/${PROJECT_NAME}.xml" "${xml}")
  endif()
endfunction()


macro(ryppl_xml_append_list variable_name indent list_tag tag)
  set(list ${ARGN})
  if(list)
    set(list "${indent}<${list_tag}>\n")
    foreach(arg ${ARGN})
      ryppl_xml_append_text(list "${indent}  " ${tag} "${arg}")
    endforeach()
    set(${variable_name} "${${variable_name}}${list}${indent}</${list_tag}>\n")
  endif()
endmacro()

macro(ryppl_xml_append_text variable_name indent tag text)
  string(REPLACE "&" "&amp;" text "${text}")
  string(REPLACE "\"" "&quot;" text "${text}")
  string(REPLACE "'" "&apos;" text "${text}")
  string(REPLACE "<" "&lt;" text "${text}")
  string(REPLACE ">" "&gt;" text "${text}")
  set(${variable_name} "${${variable_name}}${indent}<${tag}>${text}</${tag}>\n")
endmacro()
